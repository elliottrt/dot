#include "ast.h"

using tok_ptr_t = const dot::token::token *;
using tok_stack_t = std::vector<tok_ptr_t>;

using tok_group_t = std::vector<tok_ptr_t>;

dot::result::Result<std::vector<tok_group_t>, dot::error::SyntaxError> generate_groups(const tok_group_t &tokens, dot::token::token_type delim = dot::token::token_type::DOT);

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_trivial(tok_ptr_t token);
dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_array(const tok_group_t &tokens);
dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_bracketed(const tok_group_t &tokens);
dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_forward(const std::vector<tok_group_t> &tokens);
dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_application(const std::vector<tok_group_t> &tokens);
dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_function(const tok_group_t &tokens);



dot::result::Result<std::vector<tok_group_t>, dot::error::SyntaxError> generate_groups(const tok_group_t &tokens, dot::token::token_type delim) {
	// stack of (), [], {}
	tok_stack_t stack;
	// groups generated by this function
	std::vector<tok_group_t> groups;

	// start of group
	auto group_start = tokens.cbegin();
	// current position
	auto iter = tokens.cbegin();

	// for each token
	for (; iter != tokens.cend(); ++iter) {
		tok_ptr_t tok = *iter;

		// if it's a DELIM and the stack is empty then add it to the pile
		if (tok->type == delim && stack.empty()) {
			groups.push_back(tok_group_t(group_start, iter));
			group_start = iter + 1;
		// otherwise do stack operations or nothing
		} else switch (tok->type) {
			case dot::token::token_type::OPEN_PAREN:
			case dot::token::token_type::OPEN_CURLY_BRACKET:
			case dot::token::token_type::OPEN_SQUARE_BRACKET:
				stack.push_back(tok);
				break;
			case dot::token::token_type::CLOSE_PAREN:
				if (stack.empty())
					return dot::error::SyntaxError("unexpected " + tok->text, tok->row, tok->col);
				else if (stack.back()->type == dot::token::token_type::OPEN_PAREN)
					stack.pop_back();
				break;
			case dot::token::token_type::CLOSE_CURLY_BRACKET:
				if (stack.empty())
					return dot::error::SyntaxError("unexpected " + tok->text, tok->row, tok->col);
				else if (stack.back()->type == dot::token::token_type::OPEN_CURLY_BRACKET)
					stack.pop_back();
				break;
			case dot::token::token_type::CLOSE_SQUARE_BRACKET:
				if (stack.empty())
					return dot::error::SyntaxError("unexpected " + tok->text, tok->row, tok->col);
				else if (stack.back()->type == dot::token::token_type::OPEN_SQUARE_BRACKET)
					stack.pop_back();
				break;
			default:
				break;
		}
	
	}

	// add last group
	groups.push_back(tok_group_t(group_start, iter));

	// if the stack isn't empty then 1 or more things weren't closed
	if (!stack.empty()) {
		tok_ptr_t last = stack.back();
		return dot::error::SyntaxError("unclosed " + last->text, last->row, last->col);
	}

	return groups;
}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_trivial(tok_ptr_t token) {

	switch (token->type) {
		case dot::token::token_type::IDENTIFIER:
		case dot::token::token_type::ARGUMENT:
		case dot::token::token_type::SELF:
			return new dot::ast::Identifier(token->text);
		case dot::token::token_type::STRING:
			// TODO: unescape the text
			return new dot::ast::StringLiteral(token->text);
		case dot::token::token_type::INTEGER:
			// TODO: make sure there's no possibility for error here
			return new dot::ast::IntegerLiteral(std::stoi(token->text));
		default:
			return dot::error::SyntaxError("unexpected token '" + token->text + "'", token->row, token->col);
	}

}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_array(const tok_group_t &tokens) {

	auto groups_result = generate_groups(tokens, dot::token::token_type::COMMA);

	if (groups_result.is_err())
		return groups_result.err();

	std::vector<dot::ast::Node *> children;
	for (const tok_group_t &group : groups_result.ok()) {
		auto child_result = generate_forward(std::vector<tok_group_t>{group});

		if (child_result.is_err()) {
			for (dot::ast::Node *child : children) delete child;
			return child_result.err();
		}

		children.push_back(child_result.ok());
	}

	return new dot::ast::ArrayLiteral(children);
}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_bracketed(const tok_group_t &tokens) {

	// can be: (...) ()[] [...] []{} {...} {}{} {
	//	...
	// }
	// find the matching closer for the first token, and 
	// if there's elements left
	//	we error
	// else 
	//	if [] -> return generate_array(...);
	// 	if {} -> return generate_function(...);
	// 	if () -> return generate_forward(...);

	// how do we know what an array is?
	// array if: front=[, back=], front matches back -> generate_array() without front, back
	// function if front={, back=}, front matches back -> generate_tree() without front, back
	// application if front=(, back=), front matches back -> generate_application() without front, back

	if (tokens.empty())
		return dot::error::SyntaxError::LogicError(__FILE__, __LINE__);

	/*
	printf("\tgenerating bracketed...\n");
	for (auto p : tokens) {
		printf("\t\t%s:%lu:%lu: \t'%c' (%d): \"%s\"\n", "test.dot", p->row, p->col, (char) p->type, (int) p->type, p->text.c_str());
	}
	*/

	// token stack for () {} []
	tok_stack_t stack = { tokens[0] };

	dot::token::token_type open_type = tokens[0]->type;
	dot::token::token_type close_type;

	// find the open and close types
	if (open_type == dot::token::token_type::OPEN_PAREN)
		close_type = dot::token::token_type::CLOSE_PAREN;
	else if (open_type == dot::token::token_type::OPEN_CURLY_BRACKET)
		close_type = dot::token::token_type::CLOSE_CURLY_BRACKET;
	else if (open_type == dot::token::token_type::OPEN_SQUARE_BRACKET)
		close_type = dot::token::token_type::CLOSE_SQUARE_BRACKET;
	else
		return dot::error::SyntaxError::LogicError(__FILE__, __LINE__);

	// iterator
	auto iter = tokens.cbegin() + 1;
	for (; iter != tokens.cend(); ++iter) {
		if (stack.empty())
			break;
		
		// if open type then push to stack
		if ((*iter)->type == open_type)
			stack.push_back(*iter);

		// if close type then try popping from stack
		else if ((*iter)->type == close_type) {
			if (stack.empty())
				return dot::error::SyntaxError("unexpected " + (*iter)->text, (*iter)->row, (*iter)->col);
			else if (stack.back()->type == open_type)
				stack.pop_back();
		}
	}


	// tokens left in stack at the end of parsing
	if (!stack.empty()) {
		tok_ptr_t last = stack.back();
		return dot::error::SyntaxError("unexpected " + last->text, last->row, last->col);
	}
	
	// exited bracketed expression early
	if (iter != tokens.cend())
		return dot::error::SyntaxError("unexpected " + (*iter)->text, (*iter)->row, (*iter)->col);

	// remove front and back
	tok_group_t trimmed_group = tok_group_t(tokens.cbegin() + 1, tokens.cend() - 1);

	switch (open_type) {
		case dot::token::token_type::OPEN_PAREN: {
			auto child_groups = generate_groups(trimmed_group);

			if (child_groups.is_err())
				return child_groups.err();
			
			return generate_forward(child_groups.ok());
		}
		case dot::token::token_type::OPEN_CURLY_BRACKET: return generate_function(trimmed_group);
		case dot::token::token_type::OPEN_SQUARE_BRACKET: return generate_array(trimmed_group);
		default: return dot::error::SyntaxError::LogicError(__FILE__, __LINE__);
	}
}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_forward(const std::vector<tok_group_t> &tokens) {

	//printf("forwarding: group count: %lu\n", tokens.size());

	if (tokens.size() == 0)
		return dot::error::SyntaxError::LogicError(__FILE__, __LINE__);

	if (tokens.size() == 1) {
		const tok_group_t &group = tokens.front();
		//printf("\tsingle group; size = %lu\n", group.size());

		if (group.size() == 1)
			return generate_trivial(group.front());
		else 
			return generate_bracketed(group);
	}

	return generate_application(tokens);
}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_application(const std::vector<tok_group_t> &tokens) {

	if (tokens.size() < 2)
		return dot::error::SyntaxError("group size too small", -1, -1);

	std::vector<tok_group_t> target = std::vector<tok_group_t>(tokens.cbegin(), tokens.cend() - 1);
	std::vector<tok_group_t> argument = { tokens.back() };

	/*
	printf("beginning of target\n");
	for (auto v : target) {
		printf("\tgroup\n");
		for (auto p : v) {
			printf("\t\t%s:%lu:%lu: \t'%c' (%d): \"%s\"\n", "test.dot", p->row, p->col, (char) p->type, (int) p->type, p->text.c_str());
		}
	}
	printf("beginning of argument\n\tgroup\n");
	for (auto p : argument[0]) {
		printf("\t\t%s:%lu:%lu: \t'%c' (%d): \"%s\"\n", "test.dot", p->row, p->col, (char) p->type, (int) p->type, p->text.c_str());
	}
	*/

	//printf("forwording target...\n");
	auto target_result = generate_forward(target);

	if (target_result.is_err())
		return target_result.err();

	//printf("forwording argument...\n");
	auto argument_result = generate_forward(argument);

	if (argument_result.is_err())
		return argument_result.err();

	//printf("finished application\n");
	return new dot::ast::Application(
		target_result.ok(),
		argument_result.ok()
	);
}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> generate_function(const tok_group_t &tokens) {

	// elements of the root
	std::vector<dot::ast::Node *> children;
	// function declaration stack
	tok_stack_t stack; 
	// current group
	tok_group_t child_group;

	// groups are separated by dot::token::token_type::LINE_END unless within function

	for (auto iter = tokens.cbegin(); iter != tokens.cend(); ++iter) {

		// if we've reached the end of a line not in a function
		if (((*iter)->type == dot::token::token_type::LINE_END || (*iter)->type == dot::token::token_type::TOKEN_END) && stack.empty()) {
			if (child_group.size() > 0) {
				// create groups from what we have
				auto child_contents = generate_groups(child_group);

				// propagate error if needed
				if (child_contents.is_err())
					return child_contents.err();

				// generate child from groups in child
				auto child = generate_forward(child_contents.ok());

				// propagate error if needed
				if (child.is_err())
					return child.err();

				// add child and continue
				children.push_back(child.ok());
				child_group.clear();
			}
		} else if ((*iter)->type == dot::token::OPEN_CURLY_BRACKET) {
			stack.push_back(*iter);
			child_group.push_back(*iter);
		} else if ((*iter)->type == dot::token::CLOSE_CURLY_BRACKET) {
			if (stack.empty())
				return dot::error::SyntaxError("unexpected }", (*iter)->row, (*iter)->col);
			else 
				stack.pop_back();
			child_group.push_back(*iter);
		} else {
			child_group.push_back(*iter);
		}
	}

	if (!stack.empty()) {
		tok_ptr_t last = stack.back();
		return dot::error::SyntaxError("unclosed {", last->row, last->col);
	}

	return new dot::ast::FunctionDefinition(children);
}

dot::result::Result<dot::ast::Node *, dot::error::SyntaxError> dot::ast::generate_tree(const std::vector<dot::token::token> &_tokens) {
	tok_group_t tokens = tok_group_t(_tokens.size(), nullptr);

	for (size_t i = 0; i < tokens.size(); ++i)
		tokens[i] = &_tokens[i];

	return generate_function(tokens);
}
